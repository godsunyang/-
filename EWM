clc,clear
data = [100,90,100,84,90,100,100,100,100
    100,100,78.6,100,90,100,100,100,100
    75,100,85.7,100,90,100,100,100,100
    100,100,78.6,100,90,100,94.4,100,100
    100,90,100,100,100,90,100,100,80
    100,100,100,100,90,100,100,85.7,100
    100,100,78.6,100,90,100,55.6,100,100
    87.5,100,85.7,100,100,100,100,100,100
    100,100,92.9,100,80,100,100,100,100
    100,90,100,100,100,100,100,100,100
    100,100,92.9,100,90,100,100,100,100];
[Y,PS] = mapminmax(data',0,1);%由于此函数是按行进行归一化的，因此先转置再转回来就好了
to_one = Y';

ele_weight = [];
sum_col = sum(to_one); %默认按列求和
[row, col] = size(to_one); %获取原数据矩阵的行和列
for i = 1:row
    for j = 1:col
        ele_weight(i,j) = to_one(i,j)/sum_col(j); %计算出归一化后每个元素在所在特征列的占比
    end
end

E_ele = [];
for i = 1:row
    for j = 1:col
        if ele_weight(i,j) == 0 %规定0*ln(0) = 0,不赋值默认为0
            continue
        end
        E_ele(i,j) = -ele_weight(i,j)*log(ele_weight(i,j));%计算信息熵
    end
end

E = sum(E_ele./log(row));%计算此特征的信息熵
sum_E = sum(E);
W = (1-E)./(col-sum_E);%通过信息熵计算对应特征的权重
W = W';%转置便于矩阵乘法直接计算出对应的评价分数

data * W

